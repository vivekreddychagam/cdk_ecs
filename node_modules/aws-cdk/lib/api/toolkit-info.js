"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolkitInfo = exports.DEFAULT_TOOLKIT_STACK_NAME = void 0;
const colors = require("colors/safe");
const logging_1 = require("../logging");
const bootstrap_1 = require("./bootstrap");
const cloudformation_1 = require("./util/cloudformation");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * The bootstrap template version that introduced ssm:GetParameter
 */
const BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER = 5;
/**
 * Information on the Bootstrap stack of the environment we're deploying to.
 *
 * This class serves to:
 *
 * - Inspect the bootstrap stack, and return various properties of it for successful
 *   asset deployment (in case of legacy-synthesized stacks).
 * - Validate the version of the target environment, and nothing else (in case of
 *   default-synthesized stacks).
 *
 * An object of this type might represent a bootstrap stack that could not be found.
 * This is not an issue unless any members are used that require the bootstrap stack
 * to have been found, in which case an error is thrown (default-synthesized stacks
 * should never run into this as they don't need information from the bootstrap
 * stack, all information is already encoded into the Cloud Assembly Manifest).
 *
 * Nevertheless, an instance of this class exists to serve as a cache for SSM
 * parameter lookups (otherwise, the "bootstrap stack version" parameter would
 * need to be read repeatedly).
 *
 * Called "ToolkitInfo" for historical reasons.
 *
 * @experimental
 */
class ToolkitInfo {
    constructor(sdk) {
        this.sdk = sdk;
        this.ssmCache = new Map();
    }
    static determineName(overrideName) {
        return overrideName !== null && overrideName !== void 0 ? overrideName : exports.DEFAULT_TOOLKIT_STACK_NAME;
    }
    /** @experimental */
    static async lookup(environment, sdk, stackName) {
        const cfn = sdk.cloudFormation();
        const stack = await cloudformation_1.stabilizeStack(cfn, stackName !== null && stackName !== void 0 ? stackName : exports.DEFAULT_TOOLKIT_STACK_NAME);
        if (!stack) {
            logging_1.debug('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
            return ToolkitInfo.bootstrapStackNotFoundInfo(sdk);
        }
        if (stack.stackStatus.isCreationFailure) {
            // Treat a "failed to create" bootstrap stack as an absent one.
            logging_1.debug('The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
            return ToolkitInfo.bootstrapStackNotFoundInfo(sdk);
        }
        return new ExistingToolkitInfo(stack, sdk);
    }
    static fromStack(stack, sdk) {
        return new ExistingToolkitInfo(stack, sdk);
    }
    static bootstraplessDeploymentsOnly(sdk) {
        return new BootstrapStackNotFoundInfo(sdk, 'Trying to perform an operation that requires a bootstrap stack; you should not see this error, this is a bug in the CDK CLI.');
    }
    static bootstrapStackNotFoundInfo(sdk) {
        return new BootstrapStackNotFoundInfo(sdk, 'This deployment requires a bootstrap stack with a known name; pass \'--toolkit-stack-name\' or switch to using the \'DefaultStackSynthesizer\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)');
    }
    /**
     * Read a version from an SSM parameter, cached
     */
    async versionFromSsmParameter(parameterName) {
        var _a, _b;
        const existing = this.ssmCache.get(parameterName);
        if (existing !== undefined) {
            return existing;
        }
        const ssm = this.sdk.ssm();
        try {
            const result = await ssm.getParameter({ Name: parameterName }).promise();
            const asNumber = parseInt(`${(_a = result.Parameter) === null || _a === void 0 ? void 0 : _a.Value}`, 10);
            if (isNaN(asNumber)) {
                throw new Error(`SSM parameter ${parameterName} not a number: ${(_b = result.Parameter) === null || _b === void 0 ? void 0 : _b.Value}`);
            }
            this.ssmCache.set(parameterName, asNumber);
            return asNumber;
        }
        catch (e) {
            if (e.code === 'ParameterNotFound') {
                throw new Error(`SSM parameter ${parameterName} not found. Has the environment been bootstrapped? Please run \'cdk bootstrap\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
            }
            throw e;
        }
    }
}
exports.ToolkitInfo = ToolkitInfo;
/**
 * Returned when a bootstrap stack is found
 */
class ExistingToolkitInfo extends ToolkitInfo {
    constructor(bootstrapStack, sdk) {
        super(sdk);
        this.bootstrapStack = bootstrapStack;
        this.found = true;
    }
    get bucketUrl() {
        return `https://${this.requireOutput(bootstrap_1.BUCKET_DOMAIN_NAME_OUTPUT)}`;
    }
    get bucketName() {
        return this.requireOutput(bootstrap_1.BUCKET_NAME_OUTPUT);
    }
    get version() {
        var _a;
        return parseInt((_a = this.bootstrapStack.outputs[bootstrap_1.BOOTSTRAP_VERSION_OUTPUT]) !== null && _a !== void 0 ? _a : '0', 10);
    }
    get parameters() {
        var _a;
        return (_a = this.bootstrapStack.parameters) !== null && _a !== void 0 ? _a : {};
    }
    get terminationProtection() {
        var _a;
        return (_a = this.bootstrapStack.terminationProtection) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Validate that the bootstrap stack version matches or exceeds the expected version
     *
     * Use the SSM parameter name to read the version number if given, otherwise use the version
     * discovered on the bootstrap stack.
     *
     * Pass in the SSM parameter name so we can cache the lookups an don't need to do the same
     * lookup again and again for every artifact.
     */
    async validateVersion(expectedVersion, ssmParameterName) {
        let version = this.version; // Default to the current version, but will be overwritten by a lookup if required.
        if (ssmParameterName !== undefined) {
            try {
                version = await this.versionFromSsmParameter(ssmParameterName);
            }
            catch (e) {
                if (e.code !== 'AccessDeniedException') {
                    throw e;
                }
                // This is a fallback! The bootstrap template that goes along with this change introduces
                // a new 'ssm:GetParameter' permission, but when run using the previous bootstrap template we
                // won't have the permissions yet to read the version, so we won't be able to show the
                // message telling the user they need to update! When we see an AccessDeniedException, fall
                // back to the version we read from Stack Outputs; but ONLY if the version we discovered via
                // outputs is legitimately an old version. If it's newer than that, something else must be broken,
                // so let it fail as it would if we didn't have this fallback.
                if (this.version >= BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER) {
                    throw e;
                }
                logging_1.warning(`Could not read SSM parameter ${ssmParameterName}: ${e.message}`);
                // Fall through on purpose
            }
        }
        if (expectedVersion > version) {
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
        }
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     * @experimental
     */
    async prepareEcrRepository(repositoryName) {
        var _a, _b;
        if (!this.sdk) {
            throw new Error('ToolkitInfo needs to have been initialized with an sdk to call prepareEcrRepository');
        }
        const ecr = this.sdk.ecr();
        // check if repo already exists
        try {
            logging_1.debug(`${repositoryName}: checking if ECR repository already exists`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            const existingRepositoryUri = (_a = describeResponse.repositories[0]) === null || _a === void 0 ? void 0 : _a.repositoryUri;
            if (existingRepositoryUri) {
                return { repositoryUri: existingRepositoryUri };
            }
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        // create the repo (tag it so it will be easier to garbage collect in the future)
        logging_1.debug(`${repositoryName}: creating ECR repository`);
        const assetTag = { Key: 'awscdk:asset', Value: 'true' };
        const response = await ecr.createRepository({ repositoryName, tags: [assetTag] }).promise();
        const repositoryUri = (_b = response.repository) === null || _b === void 0 ? void 0 : _b.repositoryUri;
        if (!repositoryUri) {
            throw new Error(`CreateRepository did not return a repository URI for ${repositoryUri}`);
        }
        // configure image scanning on push (helps in identifying software vulnerabilities, no additional charge)
        logging_1.debug(`${repositoryName}: enable image scanning`);
        await ecr.putImageScanningConfiguration({ repositoryName, imageScanningConfiguration: { scanOnPush: true } }).promise();
        return { repositoryUri };
    }
    requireOutput(output) {
        if (!(output in this.bootstrapStack.outputs)) {
            throw new Error(`The CDK toolkit stack (${this.bootstrapStack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
        }
        return this.bootstrapStack.outputs[output];
    }
}
/**
 * Returned when a bootstrap stack could not be found
 *
 * This is not an error in principle, UNTIL one of the members is called that requires
 * the bootstrap stack to have been found, in which case the lookup error is still thrown
 * belatedly.
 *
 * The errors below serve as a last stop-gap message--normally calling code should have
 * checked `toolkit.found` and produced an appropriate error message.
 */
class BootstrapStackNotFoundInfo extends ToolkitInfo {
    constructor(sdk, errorMessage) {
        super(sdk);
        this.errorMessage = errorMessage;
        this.found = false;
    }
    get bootstrapStack() {
        throw new Error(this.errorMessage);
    }
    get bucketUrl() {
        throw new Error(this.errorMessage);
    }
    get bucketName() {
        throw new Error(this.errorMessage);
    }
    get version() {
        throw new Error(this.errorMessage);
    }
    async validateVersion(expectedVersion, ssmParameterName) {
        if (ssmParameterName === undefined) {
            throw new Error(this.errorMessage);
        }
        let version;
        try {
            version = await this.versionFromSsmParameter(ssmParameterName);
        }
        catch (e) {
            if (e.code !== 'AccessDeniedException') {
                throw e;
            }
            // This is a fallback! The bootstrap template that goes along with this change introduces
            // a new 'ssm:GetParameter' permission, but when run using a previous bootstrap template we
            // won't have the permissions yet to read the version, so we won't be able to show the
            // message telling the user they need to update! When we see an AccessDeniedException, fall
            // back to the version we read from Stack Outputs.
            logging_1.warning(`Could not read SSM parameter ${ssmParameterName}: ${e.message}`);
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found an older version. Please run 'cdk bootstrap'.`);
        }
        if (expectedVersion > version) {
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
        }
    }
    prepareEcrRepository() {
        throw new Error(this.errorMessage);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHNDQUFzQztBQUN0Qyx3Q0FBNEM7QUFFNUMsMkNBQXNHO0FBQ3RHLDBEQUE0RTtBQUUvRCxRQUFBLDBCQUEwQixHQUFHLFlBQVksQ0FBQztBQUV2RDs7R0FFRztBQUNILE1BQU0sbURBQW1ELEdBQUcsQ0FBQyxDQUFDO0FBRTlEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVCRztBQUNILE1BQXNCLFdBQVc7SUE0Qy9CLFlBQStCLEdBQVM7UUFBVCxRQUFHLEdBQUgsR0FBRyxDQUFNO1FBRnZCLGFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztJQUd0RCxDQUFDO0lBNUNNLE1BQU0sQ0FBQyxhQUFhLENBQUMsWUFBcUI7UUFDL0MsT0FBTyxZQUFZLGFBQVosWUFBWSxjQUFaLFlBQVksR0FBSSxrQ0FBMEIsQ0FBQztJQUNwRCxDQUFDO0lBRUQsb0JBQW9CO0lBQ2IsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBOEIsRUFBRSxHQUFTLEVBQUUsU0FBNkI7UUFDakcsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sS0FBSyxHQUFHLE1BQU0sK0JBQWMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxhQUFULFNBQVMsY0FBVCxTQUFTLEdBQUksa0NBQTBCLENBQUMsQ0FBQztRQUNqRixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsZUFBSyxDQUFDLG1JQUFtSSxFQUN2SSxXQUFXLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLGtCQUFrQixXQUFXLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ25GLE9BQU8sV0FBVyxDQUFDLDBCQUEwQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BEO1FBQ0QsSUFBSSxL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SUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxJQUFXLE9BQU87UUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVNLEtBQUssQ0FBQyxlQUFlLENBQUMsZUFBdUIsRUFBRSxnQkFBb0M7UUFDeEYsSUFBSSxnQkFBZ0IsS0FBSyxTQUFTLEVBQUU7WUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDcEM7UUFFRCxJQUFJLE9BQWUsQ0FBQztRQUNwQixJQUFJO1lBQ0YsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLHVCQUF1QixDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDaEU7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyx1QkFBdUIsRUFBRTtnQkFBRSxNQUFNLENBQUMsQ0FBQzthQUFFO1lBRXBELHlGQUF5RjtZQUN6RiwyRkFBMkY7WUFDM0Ysc0ZBQXNGO1lBQ3RGLDJGQUEyRjtZQUMzRixrREFBa0Q7WUFDbEQsaUJBQU8sQ0FBQyxnQ0FBZ0MsZ0JBQWdCLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsZUFBZSx3REFBd0QsQ0FBQyxDQUFDO1NBQ25KO1FBRUQsSUFBSSxlQUFlLEdBQUcsT0FBTyxFQUFFO1lBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMseURBQXlELGVBQWUsYUFBYSxPQUFPLGdDQUFnQyxDQUFDLENBQUM7U0FDL0k7SUFDSCxDQUFDO0lBRU0sb0JBQW9CO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JzL3NhZmUnO1xuaW1wb3J0IHsgZGVidWcsIHdhcm5pbmcgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuL2F3cy1hdXRoJztcbmltcG9ydCB7IEJPT1RTVFJBUF9WRVJTSU9OX09VVFBVVCwgQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVCwgQlVDS0VUX05BTUVfT1VUUFVUIH0gZnJvbSAnLi9ib290c3RyYXAnO1xuaW1wb3J0IHsgc3RhYmlsaXplU3RhY2ssIENsb3VkRm9ybWF0aW9uU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgPSAnQ0RLVG9vbGtpdCc7XG5cbi8qKlxuICogVGhlIGJvb3RzdHJhcCB0ZW1wbGF0ZSB2ZXJzaW9uIHRoYXQgaW50cm9kdWNlZCBzc206R2V0UGFyYW1ldGVyXG4gKi9cbmNvbnN0IEJPT1RTVFJBUF9URU1QTEFURV9WRVJTSU9OX0lOVFJPRFVDSU5HX0dFVFBBUkFNRVRFUiA9IDU7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gb24gdGhlIEJvb3RzdHJhcCBzdGFjayBvZiB0aGUgZW52aXJvbm1lbnQgd2UncmUgZGVwbG95aW5nIHRvLlxuICpcbiAqIFRoaXMgY2xhc3Mgc2VydmVzIHRvOlxuICpcbiAqIC0gSW5zcGVjdCB0aGUgYm9vdHN0cmFwIHN0YWNrLCBhbmQgcmV0dXJuIHZhcmlvdXMgcHJvcGVydGllcyBvZiBpdCBmb3Igc3VjY2Vzc2Z1bFxuICogICBhc3NldCBkZXBsb3ltZW50IChpbiBjYXNlIG9mIGxlZ2FjeS1zeW50aGVzaXplZCBzdGFja3MpLlxuICogLSBWYWxpZGF0ZSB0aGUgdmVyc2lvbiBvZiB0aGUgdGFyZ2V0IGVudmlyb25tZW50LCBhbmQgbm90aGluZyBlbHNlIChpbiBjYXNlIG9mXG4gKiAgIGRlZmF1bHQtc3ludGhlc2l6ZWQgc3RhY2tzKS5cbiAqXG4gKiBBbiBvYmplY3Qgb2YgdGhpcyB0eXBlIG1pZ2h0IHJlcHJlc2VudCBhIGJvb3RzdHJhcCBzdGFjayB0aGF0IGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAqIFRoaXMgaXMgbm90IGFuIGlzc3VlIHVubGVzcyBhbnkgbWVtYmVycyBhcmUgdXNlZCB0aGF0IHJlcXVpcmUgdGhlIGJvb3RzdHJhcCBzdGFja1xuICogdG8gaGF2ZSBiZWVuIGZvdW5kLCBpbiB3aGljaCBjYXNlIGFuIGVycm9yIGlzIHRocm93biAoZGVmYXVsdC1zeW50aGVzaXplZCBzdGFja3NcbiAqIHNob3VsZCBuZXZlciBydW4gaW50byB0aGlzIGFzIHRoZXkgZG9uJ3QgbmVlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBib290c3RyYXBcbiAqIHN0YWNrLCBhbGwgaW5mb3JtYXRpb24gaXMgYWxyZWFkeSBlbmNvZGVkIGludG8gdGhlIENsb3VkIEFzc2VtYmx5IE1hbmlmZXN0KS5cbiAqXG4gKiBOZXZlcnRoZWxlc3MsIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZXhpc3RzIHRvIHNlcnZlIGFzIGEgY2FjaGUgZm9yIFNTTVxuICogcGFyYW1ldGVyIGxvb2t1cHMgKG90aGVyd2lzZSwgdGhlIFwiYm9vdHN0cmFwIHN0YWNrIHZlcnNpb25cIiBwYXJhbWV0ZXIgd291bGRcbiAqIG5lZWQgdG8gYmUgcmVhZCByZXBlYXRlZGx5KS5cbiAqXG4gKiBDYWxsZWQgXCJUb29sa2l0SW5mb1wiIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVG9vbGtpdEluZm8ge1xuICBwdWJsaWMgc3RhdGljIGRldGVybWluZU5hbWUob3ZlcnJpZGVOYW1lPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlTmFtZSA/PyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRTtcbiAgfVxuXG4gIC8qKiBAZXhwZXJpbWVudGFsICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrOiBJU0RLLCBzdGFja05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8VG9vbGtpdEluZm8+IHtcbiAgICBjb25zdCBjZm4gPSBzZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBzdGFjayA9IGF3YWl0IHN0YWJpbGl6ZVN0YWNrKGNmbiwgc3RhY2tOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FKTtcbiAgICBpZiAoIXN0YWNrKSB7XG4gICAgICBkZWJ1ZygnVGhlIGVudmlyb25tZW50ICVzIGRvZXNuXFwndCBoYXZlIHRoZSBDREsgdG9vbGtpdCBzdGFjayAoJXMpIGluc3RhbGxlZC4gVXNlICVzIHRvIHNldHVwIHlvdXIgZW52aXJvbm1lbnQgZm9yIHVzZSB3aXRoIHRoZSB0b29sa2l0LicsXG4gICAgICAgIGVudmlyb25tZW50Lm5hbWUsIHN0YWNrTmFtZSwgY29sb3JzLmJsdWUoYGNkayBib290c3RyYXAgXCIke2Vudmlyb25tZW50Lm5hbWV9XCJgKSk7XG4gICAgICByZXR1cm4gVG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc2RrKTtcbiAgICB9XG4gICAgaWYgKHN0YWNrLnN0YWNrU3RhdHVzLmlzQ3JlYXRpb25GYWlsdXJlKSB7XG4gICAgICAvLyBUcmVhdCBhIFwiZmFpbGVkIHRvIGNyZWF0ZVwiIGJvb3RzdHJhcCBzdGFjayBhcyBhbiBhYnNlbnQgb25lLlxuICAgICAgZGVidWcoJ1RoZSBlbnZpcm9ubWVudCAlcyBoYXMgYSBDREsgdG9vbGtpdCBzdGFjayAoJXMpIHRoYXQgZmFpbGVkIHRvIGNyZWF0ZS4gVXNlICVzIHRvIHRyeSBwcm92aXNpb25pbmcgaXQgYWdhaW4uJyxcbiAgICAgICAgZW52aXJvbm1lbnQubmFtZSwgc3RhY2tOYW1lLCBjb2xvcnMuYmx1ZShgY2RrIGJvb3RzdHJhcCBcIiR7ZW52aXJvbm1lbnQubmFtZX1cImApKTtcbiAgICAgIHJldHVybiBUb29sa2l0SW5mby5ib290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzZGspO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRXhpc3RpbmdUb29sa2l0SW5mbyhzdGFjaywgc2RrKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YWNrKHN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrLCBzZGs6IElTREspOiBUb29sa2l0SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBFeGlzdGluZ1Rvb2xraXRJbmZvKHN0YWNrLCBzZGspO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBib290c3RyYXBsZXNzRGVwbG95bWVudHNPbmx5KHNkazogSVNESyk6IFRvb2xraXRJbmZvIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHNkaywgJ1RyeWluZyB0byBwZXJmb3JtIGFuIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIGEgYm9vdHN0cmFwIHN0YWNrOyB5b3Ugc2hvdWxkIG5vdCBzZWUgdGhpcyBlcnJvciwgdGhpcyBpcyBhIGJ1ZyBpbiB0aGUgQ0RLIENMSS4nKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc2RrOiBJU0RLKTogVG9vbGtpdEluZm8ge1xuICAgIHJldHVybiBuZXcgQm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc2RrLCAnVGhpcyBkZXBsb3ltZW50IHJlcXVpcmVzIGEgYm9vdHN0cmFwIHN0YWNrIHdpdGggYSBrbm93biBuYW1lOyBwYXNzIFxcJy0tdG9vbGtpdC1zdGFjay1uYW1lXFwnIG9yIHN3aXRjaCB0byB1c2luZyB0aGUgXFwnRGVmYXVsdFN0YWNrU3ludGhlc2l6ZXJcXCcgKHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWwpJyk7XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgZm91bmQ6IGJvb2xlYW47XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBidWNrZXRVcmw6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJ1Y2tldE5hbWU6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHZlcnNpb246IG51bWJlcjtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJvb3RzdHJhcFN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgc3NtQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBzZGs6IElTREspIHtcbiAgfVxuICBwdWJsaWMgYWJzdHJhY3QgdmFsaWRhdGVWZXJzaW9uKGV4cGVjdGVkVmVyc2lvbjogbnVtYmVyLCBzc21QYXJhbWV0ZXJOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+O1xuICBwdWJsaWMgYWJzdHJhY3QgcHJlcGFyZUVjclJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWU6IHN0cmluZyk6IFByb21pc2U8RWNyUmVwb3NpdG9yeUluZm8+O1xuXG4gIC8qKlxuICAgKiBSZWFkIGEgdmVyc2lvbiBmcm9tIGFuIFNTTSBwYXJhbWV0ZXIsIGNhY2hlZFxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHZlcnNpb25Gcm9tU3NtUGFyYW1ldGVyKHBhcmFtZXRlck5hbWU6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLnNzbUNhY2hlLmdldChwYXJhbWV0ZXJOYW1lKTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZXhpc3Rpbmc7IH1cblxuICAgIGNvbnN0IHNzbSA9IHRoaXMuc2RrLnNzbSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNzbS5nZXRQYXJhbWV0ZXIoeyBOYW1lOiBwYXJhbWV0ZXJOYW1lIH0pLnByb21pc2UoKTtcblxuICAgICAgY29uc3QgYXNOdW1iZXIgPSBwYXJzZUludChgJHtyZXN1bHQuUGFyYW1ldGVyPy5WYWx1ZX1gLCAxMCk7XG4gICAgICBpZiAoaXNOYU4oYXNOdW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU1NNIHBhcmFtZXRlciAke3BhcmFtZXRlck5hbWV9IG5vdCBhIG51bWJlcjogJHtyZXN1bHQuUGFyYW1ldGVyPy5WYWx1ZX1gKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zc21DYWNoZS5zZXQocGFyYW1ldGVyTmFtZSwgYXNOdW1iZXIpO1xuICAgICAgcmV0dXJuIGFzTnVtYmVyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdQYXJhbWV0ZXJOb3RGb3VuZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTU00gcGFyYW1ldGVyICR7cGFyYW1ldGVyTmFtZX0gbm90IGZvdW5kLiBIYXMgdGhlIGVudmlyb25tZW50IGJlZW4gYm9vdHN0cmFwcGVkPyBQbGVhc2UgcnVuIFxcJ2NkayBib290c3RyYXBcXCcgKHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWwpYCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBib290c3RyYXAgc3RhY2sgaXMgZm91bmRcbiAqL1xuY2xhc3MgRXhpc3RpbmdUb29sa2l0SW5mbyBleHRlbmRzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHJlYWRvbmx5IGZvdW5kID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2ssIHNkazogSVNESykge1xuICAgIHN1cGVyKHNkayk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldFVybCgpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLnJlcXVpcmVPdXRwdXQoQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVCl9YDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlT3V0cHV0KEJVQ0tFVF9OQU1FX09VVFBVVCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0c1tCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVRdID8/ICcwJywgMTApO1xuICB9XG5cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnBhcmFtZXRlcnMgPz8ge307XG4gIH1cblxuICBwdWJsaWMgZ2V0IHRlcm1pbmF0aW9uUHJvdGVjdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ib290c3RyYXBTdGFjay50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCB0aGUgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gbWF0Y2hlcyBvciBleGNlZWRzIHRoZSBleHBlY3RlZCB2ZXJzaW9uXG4gICAqXG4gICAqIFVzZSB0aGUgU1NNIHBhcmFtZXRlciBuYW1lIHRvIHJlYWQgdGhlIHZlcnNpb24gbnVtYmVyIGlmIGdpdmVuLCBvdGhlcndpc2UgdXNlIHRoZSB2ZXJzaW9uXG4gICAqIGRpc2NvdmVyZWQgb24gdGhlIGJvb3RzdHJhcCBzdGFjay5cbiAgICpcbiAgICogUGFzcyBpbiB0aGUgU1NNIHBhcmFtZXRlciBuYW1lIHNvIHdlIGNhbiBjYWNoZSB0aGUgbG9va3VwcyBhbiBkb24ndCBuZWVkIHRvIGRvIHRoZSBzYW1lXG4gICAqIGxvb2t1cCBhZ2FpbiBhbmQgYWdhaW4gZm9yIGV2ZXJ5IGFydGlmYWN0LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHZhbGlkYXRlVmVyc2lvbihleHBlY3RlZFZlcnNpb246IG51bWJlciwgc3NtUGFyYW1ldGVyTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgbGV0IHZlcnNpb24gPSB0aGlzLnZlcnNpb247IC8vIERlZmF1bHQgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbiwgYnV0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYSBsb29rdXAgaWYgcmVxdWlyZWQuXG5cbiAgICBpZiAoc3NtUGFyYW1ldGVyTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gYXdhaXQgdGhpcy52ZXJzaW9uRnJvbVNzbVBhcmFtZXRlcihzc21QYXJhbWV0ZXJOYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSAhPT0gJ0FjY2Vzc0RlbmllZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgYSBmYWxsYmFjayEgVGhlIGJvb3RzdHJhcCB0ZW1wbGF0ZSB0aGF0IGdvZXMgYWxvbmcgd2l0aCB0aGlzIGNoYW5nZSBpbnRyb2R1Y2VzXG4gICAgICAgIC8vIGEgbmV3ICdzc206R2V0UGFyYW1ldGVyJyBwZXJtaXNzaW9uLCBidXQgd2hlbiBydW4gdXNpbmcgdGhlIHByZXZpb3VzIGJvb3RzdHJhcCB0ZW1wbGF0ZSB3ZVxuICAgICAgICAvLyB3b24ndCBoYXZlIHRoZSBwZXJtaXNzaW9ucyB5ZXQgdG8gcmVhZCB0aGUgdmVyc2lvbiwgc28gd2Ugd29uJ3QgYmUgYWJsZSB0byBzaG93IHRoZVxuICAgICAgICAvLyBtZXNzYWdlIHRlbGxpbmcgdGhlIHVzZXIgdGhleSBuZWVkIHRvIHVwZGF0ZSEgV2hlbiB3ZSBzZWUgYW4gQWNjZXNzRGVuaWVkRXhjZXB0aW9uLCBmYWxsXG4gICAgICAgIC8vIGJhY2sgdG8gdGhlIHZlcnNpb24gd2UgcmVhZCBmcm9tIFN0YWNrIE91dHB1dHM7IGJ1dCBPTkxZIGlmIHRoZSB2ZXJzaW9uIHdlIGRpc2NvdmVyZWQgdmlhXG4gICAgICAgIC8vIG91dHB1dHMgaXMgbGVnaXRpbWF0ZWx5IGFuIG9sZCB2ZXJzaW9uLiBJZiBpdCdzIG5ld2VyIHRoYW4gdGhhdCwgc29tZXRoaW5nIGVsc2UgbXVzdCBiZSBicm9rZW4sXG4gICAgICAgIC8vIHNvIGxldCBpdCBmYWlsIGFzIGl0IHdvdWxkIGlmIHdlIGRpZG4ndCBoYXZlIHRoaXMgZmFsbGJhY2suXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPj0gQk9PVFNUUkFQX1RFTVBMQVRFX1ZFUlNJT05fSU5UUk9EVUNJTkdfR0VUUEFSQU1FVEVSKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5pbmcoYENvdWxkIG5vdCByZWFkIFNTTSBwYXJhbWV0ZXIgJHtzc21QYXJhbWV0ZXJOYW1lfTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCBvbiBwdXJwb3NlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4cGVjdGVkVmVyc2lvbiA+IHZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBDREsgZGVwbG95bWVudCByZXF1aXJlcyBib290c3RyYXAgc3RhY2sgdmVyc2lvbiAnJHtleHBlY3RlZFZlcnNpb259JywgZm91bmQgJyR7dmVyc2lvbn0nLiBQbGVhc2UgcnVuICdjZGsgYm9vdHN0cmFwJy5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbiBFQ1IgcmVwb3NpdG9yeSBmb3IgdXBsb2FkaW5nIHRvIHVzaW5nIERvY2tlclxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcHJlcGFyZUVjclJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWU6IHN0cmluZyk6IFByb21pc2U8RWNyUmVwb3NpdG9yeUluZm8+IHtcbiAgICBpZiAoIXRoaXMuc2RrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rvb2xraXRJbmZvIG5lZWRzIHRvIGhhdmUgYmVlbiBpbml0aWFsaXplZCB3aXRoIGFuIHNkayB0byBjYWxsIHByZXBhcmVFY3JSZXBvc2l0b3J5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGVjciA9IHRoaXMuc2RrLmVjcigpO1xuXG4gICAgLy8gY2hlY2sgaWYgcmVwbyBhbHJlYWR5IGV4aXN0c1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgJHtyZXBvc2l0b3J5TmFtZX06IGNoZWNraW5nIGlmIEVDUiByZXBvc2l0b3J5IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICBjb25zdCBkZXNjcmliZVJlc3BvbnNlID0gYXdhaXQgZWNyLmRlc2NyaWJlUmVwb3NpdG9yaWVzKHsgcmVwb3NpdG9yeU5hbWVzOiBbcmVwb3NpdG9yeU5hbWVdIH0pLnByb21pc2UoKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUmVwb3NpdG9yeVVyaSA9IGRlc2NyaWJlUmVzcG9uc2UucmVwb3NpdG9yaWVzIVswXT8ucmVwb3NpdG9yeVVyaTtcbiAgICAgIGlmIChleGlzdGluZ1JlcG9zaXRvcnlVcmkpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVwb3NpdG9yeVVyaTogZXhpc3RpbmdSZXBvc2l0b3J5VXJpIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSAhPT0gJ1JlcG9zaXRvcnlOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgcmVwbyAodGFnIGl0IHNvIGl0IHdpbGwgYmUgZWFzaWVyIHRvIGdhcmJhZ2UgY29sbGVjdCBpbiB0aGUgZnV0dXJlKVxuICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY3JlYXRpbmcgRUNSIHJlcG9zaXRvcnlgKTtcbiAgICBjb25zdCBhc3NldFRhZyA9IHsgS2V5OiAnYXdzY2RrOmFzc2V0JywgVmFsdWU6ICd0cnVlJyB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWNyLmNyZWF0ZVJlcG9zaXRvcnkoeyByZXBvc2l0b3J5TmFtZSwgdGFnczogW2Fzc2V0VGFnXSB9KS5wcm9taXNlKCk7XG4gICAgY29uc3QgcmVwb3NpdG9yeVVyaSA9IHJlc3BvbnNlLnJlcG9zaXRvcnk/LnJlcG9zaXRvcnlVcmk7XG4gICAgaWYgKCFyZXBvc2l0b3J5VXJpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENyZWF0ZVJlcG9zaXRvcnkgZGlkIG5vdCByZXR1cm4gYSByZXBvc2l0b3J5IFVSSSBmb3IgJHtyZXBvc2l0b3J5VXJpfWApO1xuICAgIH1cblxuICAgIC8vIGNvbmZpZ3VyZSBpbWFnZSBzY2FubmluZyBvbiBwdXNoIChoZWxwcyBpbiBpZGVudGlmeWluZyBzb2Z0d2FyZSB2dWxuZXJhYmlsaXRpZXMsIG5vIGFkZGl0aW9uYWwgY2hhcmdlKVxuICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogZW5hYmxlIGltYWdlIHNjYW5uaW5nYCk7XG4gICAgYXdhaXQgZWNyLnB1dEltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uKHsgcmVwb3NpdG9yeU5hbWUsIGltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uOiB7IHNjYW5PblB1c2g6IHRydWUgfSB9KS5wcm9taXNlKCk7XG5cbiAgICByZXR1cm4geyByZXBvc2l0b3J5VXJpIH07XG4gIH1cblxuICBwcml2YXRlIHJlcXVpcmVPdXRwdXQob3V0cHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghKG91dHB1dCBpbiB0aGlzLmJvb3RzdHJhcFN0YWNrLm91dHB1dHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBDREsgdG9vbGtpdCBzdGFjayAoJHt0aGlzLmJvb3RzdHJhcFN0YWNrLnN0YWNrTmFtZX0pIGRvZXMgbm90IGhhdmUgYW4gb3V0cHV0IG5hbWVkICR7b3V0cHV0fS4gVXNlICdjZGsgYm9vdHN0cmFwJyB0byBjb3JyZWN0IHRoaXMuYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLm91dHB1dHNbb3V0cHV0XTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBib290c3RyYXAgc3RhY2sgY291bGQgbm90IGJlIGZvdW5kXG4gKlxuICogVGhpcyBpcyBub3QgYW4gZXJyb3IgaW4gcHJpbmNpcGxlLCBVTlRJTCBvbmUgb2YgdGhlIG1lbWJlcnMgaXMgY2FsbGVkIHRoYXQgcmVxdWlyZXNcbiAqIHRoZSBib290c3RyYXAgc3RhY2sgdG8gaGF2ZSBiZWVuIGZvdW5kLCBpbiB3aGljaCBjYXNlIHRoZSBsb29rdXAgZXJyb3IgaXMgc3RpbGwgdGhyb3duXG4gKiBiZWxhdGVkbHkuXG4gKlxuICogVGhlIGVycm9ycyBiZWxvdyBzZXJ2ZSBhcyBhIGxhc3Qgc3RvcC1nYXAgbWVzc2FnZS0tbm9ybWFsbHkgY2FsbGluZyBjb2RlIHNob3VsZCBoYXZlXG4gKiBjaGVja2VkIGB0b29sa2l0LmZvdW5kYCBhbmQgcHJvZHVjZWQgYW4gYXBwcm9wcmlhdGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuY2xhc3MgQm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8gZXh0ZW5kcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyByZWFkb25seSBmb3VuZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHNkazogSVNESywgcHJpdmF0ZSByZWFkb25seSBlcnJvck1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKHNkayk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJvb3RzdHJhcFN0YWNrKCk6IENsb3VkRm9ybWF0aW9uU3RhY2sge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldFVybCgpOiBzdHJpbmcge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldE5hbWUoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCB2ZXJzaW9uKCk6IG51bWJlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB2YWxpZGF0ZVZlcnNpb24oZXhwZWN0ZWRWZXJzaW9uOiBudW1iZXIsIHNzbVBhcmFtZXRlck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChzc21QYXJhbWV0ZXJOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgbGV0IHZlcnNpb246IG51bWJlcjtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbiA9IGF3YWl0IHRoaXMudmVyc2lvbkZyb21Tc21QYXJhbWV0ZXIoc3NtUGFyYW1ldGVyTmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSAhPT0gJ0FjY2Vzc0RlbmllZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuXG4gICAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2shIFRoZSBib290c3RyYXAgdGVtcGxhdGUgdGhhdCBnb2VzIGFsb25nIHdpdGggdGhpcyBjaGFuZ2UgaW50cm9kdWNlc1xuICAgICAgLy8gYSBuZXcgJ3NzbTpHZXRQYXJhbWV0ZXInIHBlcm1pc3Npb24sIGJ1dCB3aGVuIHJ1biB1c2luZyBhIHByZXZpb3VzIGJvb3RzdHJhcCB0ZW1wbGF0ZSB3ZVxuICAgICAgLy8gd29uJ3QgaGF2ZSB0aGUgcGVybWlzc2lvbnMgeWV0IHRvIHJlYWQgdGhlIHZlcnNpb24sIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gc2hvdyB0aGVcbiAgICAgIC8vIG1lc3NhZ2UgdGVsbGluZyB0aGUgdXNlciB0aGV5IG5lZWQgdG8gdXBkYXRlISBXaGVuIHdlIHNlZSBhbiBBY2Nlc3NEZW5pZWRFeGNlcHRpb24sIGZhbGxcbiAgICAgIC8vIGJhY2sgdG8gdGhlIHZlcnNpb24gd2UgcmVhZCBmcm9tIFN0YWNrIE91dHB1dHMuXG4gICAgICB3YXJuaW5nKGBDb3VsZCBub3QgcmVhZCBTU00gcGFyYW1ldGVyICR7c3NtUGFyYW1ldGVyTmFtZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIENESyBkZXBsb3ltZW50IHJlcXVpcmVzIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uICcke2V4cGVjdGVkVmVyc2lvbn0nLCBmb3VuZCBhbiBvbGRlciB2ZXJzaW9uLiBQbGVhc2UgcnVuICdjZGsgYm9vdHN0cmFwJy5gKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0ZWRWZXJzaW9uID4gdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIENESyBkZXBsb3ltZW50IHJlcXVpcmVzIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uICcke2V4cGVjdGVkVmVyc2lvbn0nLCBmb3VuZCAnJHt2ZXJzaW9ufScuIFBsZWFzZSBydW4gJ2NkayBib290c3RyYXAnLmApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwcmVwYXJlRWNyUmVwb3NpdG9yeSgpOiBQcm9taXNlPEVjclJlcG9zaXRvcnlJbmZvPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGludGVyZmFjZSBFY3JSZXBvc2l0b3J5SW5mbyB7XG4gIHJlcG9zaXRvcnlVcmk6IHN0cmluZztcbn1cblxuLyoqIEBleHBlcmltZW50YWwgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWNyQ3JlZGVudGlhbHMge1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufSJdfQ==